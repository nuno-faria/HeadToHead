# state - map with the observable state
# data - map to store data

#matched strings in a node's action and decision gets replaced by the repective value
expressions:
  wait_pos_x: 3
  ball_range_to_jump_max_x: 2
  ball_range_to_jump_max_y: 2
  min_distance_from_ball_x: 0.4 # so it shoots the ball left/right instead of up
  horizontal_speed: 1.75
  max_ball_y_to_follow: 0.5   #sufficient condition to follow the ball
  max_ball_xvel_to_follow: 8   #sufficient condition to follow the ball
  max_ball_yvel_to_follow: -4   #sufficient condition to follow the ball
  wall_x: 8.9
  floor_y: -3.6
  ball_in_self_area: state["ballPosX"] > 0 # can be code too

  # can also refer to state/data variables
  # ex: ballPosX: state["ballPosX"]
  # ex: x_dist_to_ball: abs(state["selfPosX"] - state["ballPosX"])
  # ex:  custom_x: data["_x"]
  #       NODE:
  #         action: custom_x = ballPosX


nodes:
  # root
  ROOT:
    decision: ball_in_self_area # ball in players area
    yes: GO_BALL
    no: GO_WAIT_POS

  # find where to go (follow the ball or go to the fall prediction)
  GO_BALL:
    decision: >-
      state["ballPosY"] < max_ball_y_to_follow ||
      state["ballVelX"] < max_ball_xvel_to_follow ||
      state["ballVelY"] < max_ball_yvel_to_follow
    yes: FOLLOW_BALL; SPRINT; JUMP_TO_BALL
    no: GO_PREDICT_FALL; SPRINT; JUMP_TO_BALL

  # move to the ball
  FOLLOW_BALL:
    action: data["_x"] = state["ballPosX"] # to be used in MOVE_TO_CUSTOM_POS
    decision: abs(state["selfPosX"] - state["ballPosX"]) > min_distance_from_ball_x
    yes: MOVE_TO_CUSTOM_POS
    #if 'no' it does nothing 

  # jump to ball
  JUMP_TO_BALL:
    decision: >-
      abs(state["selfPosX"] - state["ballPosX"]) < ball_range_to_jump_max_x && 
      abs(state["selfPosY"] - state["ballPosY"]) < ball_range_to_jump_max_y
    yes: JUMP

  # move to the wait pos
  GO_WAIT_POS:
    action: data["_x"] = wait_pos_x
    yes: MOVE_TO_CUSTOM_POS # yes without decision is always executed

  # move to the position where the ball is most likely to fall
  GO_PREDICT_FALL:
    action: >-
        data["_ballFallX"] = (floor_y - state["ballPosY"]) / (state["ballVelY"] / state["ballVelX"]) + state["ballPosX"];
        data["_ballFallX"] = data["_ballFallX"] > wall_x ? wall_x - (data["_ballFallX"] - wall_x) : data["_ballFallX"];
        data["_x"] = data["_ballFallX"];
    yes: MOVE_TO_CUSTOM_POS


  # moves the player to some position (data["_x"]) previously set
  MOVE_TO_CUSTOM_POS:
    decision: state["selfPosX"] < data["_x"]
    yes: MOVE_RIGHT
    no: MOVE_LEFT

  MOVE_RIGHT: data["horizontal"] = horizontal_speed
  #same as:
  #  MOVE_RIGHT:
  #    action: data["horizontal"] = horizontal_speed

  MOVE_LEFT: data["horizontal"] = -1 * horizontal_speed

  SPRINT: data["sprint"] = 1

  JUMP: data["jump"] = 1